name: Auth v2 Protection Gates

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  # Phase A: Immediate CI Gates - Production Contract Validation
  auth-contracts-prod-smoke:
    name: Auth Contracts (Production)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Newman (Postman CLI)
        run: npm install -g newman

      - name: Test Auth Contracts
        run: |
          # Set canonical base URL
          BASE=https://www.glowme.io
          
          # Health check with redirect following
          echo "Testing /api/health..."
          curl -L -sS -D /tmp/health_headers.txt -o /tmp/health.json "${BASE}/api/health"
          HTTP_CODE=$(awk 'toupper($1)=="HTTP/"{c=$2} END{print c}' /tmp/health_headers.txt)
          CONTENT_TYPE=$(awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' /tmp/health_headers.txt | tail -1)
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Health check failed: HTTP $HTTP_CODE"
            cat /tmp/health_headers.txt
            exit 1
          fi
          
          case "$CONTENT_TYPE" in
            application/json* ) ;;
            * ) echo "‚ùå Health check returned non-JSON: $CONTENT_TYPE"; exit 1 ;;
          esac
          
          echo "‚úÖ Health check passed"

          # Login contract test with cookie jar
          echo "Testing /api/auth/login contract..."
          JAR=/tmp/cookies.txt
          curl -L -sS -c "$JAR" -D /tmp/login_headers.txt -o /tmp/login.json \
            -H 'Content-Type: application/json' \
            -X POST "${BASE}/api/auth/login" \
            --data '{"email":"admin@glow.app","password":"admin123"}'
          
          LOGIN_CODE=$(awk 'toupper($1)=="HTTP/"{c=$2} END{print c}' /tmp/login_headers.txt)
          LOGIN_CTYPE=$(awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' /tmp/login_headers.txt | tail -1)
          
          # Check for 200 status
          if [ "$LOGIN_CODE" != "200" ]; then
            echo "‚ùå Login failed - HTTP $LOGIN_CODE"
            cat /tmp/login_headers.txt
            exit 1
          fi
          
          # Check for JSON content type
          case "$LOGIN_CTYPE" in
            application/json* ) ;;
            * ) echo "‚ùå Login returned non-JSON: $LOGIN_CTYPE"; exit 1 ;;
          esac
          
          # Check for required cookie attributes
          COOKIE_LINE=$(grep -i '^set-cookie:' /tmp/login_headers.txt | grep -i 'glow_session=' | tail -1)
          
          if [[ -z "$COOKIE_LINE" ]]; then
            echo "‚ùå No glow_session cookie found"
            cat /tmp/login_headers.txt
            exit 1
          fi
          
          if [[ "$COOKIE_LINE" != *"HttpOnly"* ]]; then
            echo "‚ùå Missing HttpOnly attribute: $COOKIE_LINE"
            exit 1
          fi
          
          if [[ "$COOKIE_LINE" != *"Secure"* ]]; then
            echo "‚ùå Missing Secure attribute: $COOKIE_LINE"
            exit 1
          fi
          
          if [[ "$COOKIE_LINE" != *"SameSite=Lax"* ]]; then
            echo "‚ùå Missing SameSite=Lax attribute: $COOKIE_LINE"
            exit 1
          fi
          
          if [[ "$COOKIE_LINE" != *"Path=/"* ]]; then
            echo "‚ùå Missing Path=/ attribute: $COOKIE_LINE"
            exit 1
          fi
          
          echo "‚úÖ Login contract passed"
          
          # Test /me with cookie jar (authenticated)
          echo "Testing /api/auth/me (authenticated)..."
          curl -L -sS -b "$JAR" -D /tmp/me_headers.txt -o /tmp/me.json "${BASE}/api/auth/me"
          
          ME_HTTP_CODE=$(awk 'toupper($1)=="HTTP/"{c=$2} END{print c}' /tmp/me_headers.txt)
          ME_CONTENT_TYPE=$(awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' /tmp/me_headers.txt | tail -1)
          
          if [ "$ME_HTTP_CODE" != "200" ]; then
            echo "‚ùå /me authenticated failed: HTTP $ME_HTTP_CODE"
            cat /tmp/me_headers.txt
            exit 1
          fi
          
          case "$ME_CONTENT_TYPE" in
            application/json* ) ;;
            * ) echo "‚ùå /me authenticated returned non-JSON: $ME_CONTENT_TYPE"; exit 1 ;;
          esac
          
          echo "‚úÖ /me authenticated passed"
          
          # Test logout
          echo "Testing /api/auth/logout..."
          curl -L -sS -b "$JAR" -D /tmp/logout_headers.txt -o /tmp/logout.json \
            -X POST "${BASE}/api/auth/logout"
          
          LOGOUT_HTTP_CODE=$(awk 'toupper($1)=="HTTP/"{c=$2} END{print c}' /tmp/logout_headers.txt)
          LOGOUT_CONTENT_TYPE=$(awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' /tmp/logout_headers.txt | tail -1)
          
          if [ "$LOGOUT_HTTP_CODE" != "200" ]; then
            echo "‚ùå Logout failed: HTTP $LOGOUT_HTTP_CODE"
            cat /tmp/logout_headers.txt
            exit 1
          fi
          
          case "$LOGOUT_CONTENT_TYPE" in
            application/json* ) ;;
            * ) echo "‚ùå Logout returned non-JSON: $LOGOUT_CONTENT_TYPE"; exit 1 ;;
          esac
          
          echo "‚úÖ Logout passed"
          
          # Test /me without cookie (unauthenticated)
          echo "Testing /api/auth/me (unauthenticated)..."
          curl -L -sS -D /tmp/me2_headers.txt -o /tmp/me2.json "${BASE}/api/auth/me"
          
          ME_UNAUTH_HTTP_CODE=$(awk 'toupper($1)=="HTTP/"{c=$2} END{print c}' /tmp/me2_headers.txt)
          ME_UNAUTH_CONTENT_TYPE=$(awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' /tmp/me2_headers.txt | tail -1)
          
          if [ "$ME_UNAUTH_HTTP_CODE" != "401" ]; then
            echo "‚ùå /me unauthenticated should return 401, got: HTTP $ME_UNAUTH_HTTP_CODE"
            cat /tmp/me2_headers.txt
            exit 1
          fi
          
          case "$ME_UNAUTH_CONTENT_TYPE" in
            application/json* ) ;;
            * ) echo "‚ùå /me unauthenticated returned non-JSON: $ME_UNAUTH_CONTENT_TYPE"; exit 1 ;;
          esac
          
          echo "‚úÖ /me unauthenticated passed"
          echo "üéâ All auth contracts validated successfully!"

  # Phase C: Static Guards - Forbidden Pattern Detection
  auth-static-guards:
    name: Auth Static Guards
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for forbidden patterns
        run: |
          echo "Checking for forbidden patterns in frontend code..."
          
          # Check for absolute URLs in API client (exclude external APIs like OpenStreetMap)
          if grep -r "https\?://" src/ --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" | grep -v "//.*https\?://" | grep -v "console\|comment" | grep -v "nominatim.openstreetmap.org\|images.unsplash.com" | grep -E "(api|auth|login|logout|me)" ; then
            echo "‚ùå Found absolute URLs in auth-related frontend code (should use relative /api/*)"
            exit 1
          fi
          
          # Check for Authorization headers
          if grep -r "Authorization\|Bearer " src/ --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" | grep -v "//.*Authorization\|//.*Bearer"; then
            echo "‚ùå Found Authorization/Bearer headers (Auth v2 uses cookies only)"
            exit 1
          fi
          
          # Check for token storage (exclude cleanup of old storage)
          if grep -r "localStorage.*token\|sessionStorage.*token" src/ --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" | grep -v "removeItem.*glow-auth-store"; then
            echo "‚ùå Found token storage in localStorage/sessionStorage (Auth v2 uses cookies only)"
            exit 1
          fi
          
          # Check for throwing on /me 401 (simplified check)
          if grep -A5 -B5 "/api/auth/me" src/ --include="*.ts" --include="*.tsx" | grep -A10 -B10 "throw.*401\|throw.*AUTH_REQUIRED"; then
            echo "‚ùå Found throwing on /me 401 (should treat as valid unauthenticated state)"
            exit 1
          fi
          
          echo "‚úÖ All static guards passed"

  # Phase B: Preview E2E (placeholder for now)
  auth-e2e-preview:
    name: Auth E2E (Preview)
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Placeholder E2E test
        run: |
          echo "üöß E2E tests will be implemented in Phase B"
          echo "This job ensures the workflow structure is ready"
          echo "‚úÖ Placeholder passed"

