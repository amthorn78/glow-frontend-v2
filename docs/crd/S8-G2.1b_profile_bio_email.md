# CRD: S8-G2.1b_profileâ€”Bio Wire-Up + Email Read-Only

## Goal

Finish the Profile page solidity by:

1. Fixing the Bio field (populate, edit, save, validate, show typed errors, live counter).
2. Locking Email as read-only (display only; never submitted).

## Implementation

### Bio Field Fixes

1. **Restored `onChange` handler**: Added back `onChange={handleInputChange}` to the bio textarea to make it editable.
2. **Added Null Safety**: Updated the bio textarea `value` to `formData.bio ?? ''` and the character counter to use `(formData.bio ?? '').length`.
3. **Enhanced Error Handling**: Added `fieldErrors` state and logic to display typed validation errors for the bio field.
4. **Payload Cleanup**: Removed extra fields from the `basicInfoPayload` to only send `{first_name, last_name, bio}`.

### Email Read-Only

1. **Read-Only Input**: Made the email field read-only with `readOnly` and `aria-readonly="true"`.
2. **Visual Styling**: Added `bg-gray-50 text-gray-600 cursor-not-allowed` for a clear read-only appearance.
3. **Helper Text**: Added "Email is managed separately" below the email field.
4. **Removed from State**: Removed email from `formData` state and initialization.
5. **Direct Binding**: Email field now reads directly from `user?.email ?? ''`.

## Unified Diff

```diff
diff --git a/src/pages/ProfilePage.tsx b/src/pages/ProfilePage.tsx
index cfaaf5e6..6062925e 100644
--- a/src/pages/ProfilePage.tsx
+++ b/src/pages/ProfilePage.tsx
@@ -24,11 +24,11 @@ const ProfilePage: React.FC = () => {
   const [formData, setFormData] = useState({
     first_name: 
     last_name: 
-    email: 
     bio: 
   });
   const [loading, setLoading] = useState(false);
   const [message, setMessage] = useState<{ type: | ", text: string } | null>(null);
+  const [fieldErrors, setFieldErrors] = useState<{ [key: string]: string }>({});
 
   // Redirect if not authenticated
   useEffect(() => {
@@ -43,7 +43,6 @@ const ProfilePage: React.FC = () => {
       setFormData({
         first_name: user.first_name || 
         last_name: user.last_name || 
-        email: user.email || 
         bio: user.bio || 
       });
     }
@@ -68,14 +67,11 @@ const ProfilePage: React.FC = () => {
     setMessage(null);
 
     try {
-      // Prepare basic info payload (exclude email - that
+      // Prepare basic info payload - only send fields the backend expects
       const basicInfoPayload = {
-        display_name: formData.display_name || null,
-        first_name: formData.first_name || null,
-        last_name: formData.last_name || null,
-        bio: formData.bio || null,
-        age: formData.age || null,
-        avatar_url: formData.avatar_url || null
+        first_name: formData.first_name?.trim() ?? 
+        last_name: formData.last_name?.trim() ?? 
+        bio: formData.bio ?? 
       };
 
       // Save via centralized CSRF wrapper
@@ -83,14 +79,25 @@ const ProfilePage: React.FC = () => {
 
       if (response.ok) {
         setMessage({ type: ", text: 
-        setEditingSection(null);
+        setEditingSection(null);
+        setFieldErrors({}); // Clear any previous field errors
 
         // Invalidate and refetch /api/auth/me (round-trip guarantee)
         await queryClient.invalidateQueries({ queryKey: [,] });
         await queryClient.refetchQueries({ queryKey: [,] });
       } else {
-        setMessage({ 
-          type: 
-          text: response.error || 
+        // Handle typed validation errors
+        if (response.error ===  && response.details) {
+          const errors: { [key: string]: string } = {};
+          Object.keys(response.details).forEach(field => {
+            if (response.details[field] && response.details[field][0]) {
+              errors[field] = response.details[field][0];
+            }
+          });
+          setFieldErrors(errors);
+        }
+        
+        setMessage({ 
+          type: 
+          text: response.error || 
         });
       }
     } catch (error) {
@@ -243,24 +249,15 @@ const ProfilePage: React.FC = () => {
                 <label className=
                   Email *
                 </label>
-                <input
-                  type=
-                  name=
-                  value={formData.email}
-                  onChange={handleInputChange}
-                  className=
-                  required
-                />
+                <input
+                  type=
+                  name=
+                  value={user?.email ?? 
+                  readOnly
+                  aria-readonly=
+                  className=
+                />
+                <p className=
               </div>
 
               <div>
@@ -270,11 +267,19 @@ const ProfilePage: React.FC = () => {
                 <textarea
                   name=
-                  value={formData.bio}
-                  onChange={handleInputChange}
+                  value={formData.bio ?? 
+                  onChange={handleInputChange}
                   rows={3}
+                  maxLength={500}
                   placeholder=
                   className=
                 />
+                <div className=
+                  {(formData.bio ?? ).length}/500 characters
+                </div>
+                {fieldErrors.bio && (
+                  <div className=
+                    {fieldErrors.bio}
+                  </div>
+                )}
               </div>
 
               <div className=
```

## Manual Test Plan

1. **Populate**: Open `/profile`, confirm first name, last name, email, and bio populate correctly.
2. **Bio Editable**: Edit bio, confirm counter updates, save, expect 200, refresh, confirm persistence.
3. **Email Read-Only**: Try to edit email, confirm it's not possible.
4. **Character Limit**: Enter >500 chars in bio, confirm limit enforcement and counter caps at 500.
5. **Validation**: Force backend validation error for bio, confirm typed error is shown inline.
6. **Payload Clean**: Inspect save request, confirm only `{first_name, last_name, bio}` are sent.


