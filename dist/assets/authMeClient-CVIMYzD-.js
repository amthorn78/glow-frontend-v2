class o{constructor(){this.abortController=null,this.coalesceTimer=null,this.pendingPromise=null,this.pendingResolvers=[]}async fetchAuthMe(){return this.pendingPromise?new Promise((t,e)=>{this.pendingResolvers.push({resolve:t,reject:e})}):this.coalesceTimer?new Promise((t,e)=>{this.pendingResolvers.push({resolve:t,reject:e})}):new Promise((t,e)=>{this.pendingResolvers.push({resolve:t,reject:e}),this.coalesceTimer=setTimeout(()=>{this.executeRequest()},200)})}async executeRequest(){this.coalesceTimer&&(clearTimeout(this.coalesceTimer),this.coalesceTimer=null),this.abortController&&this.abortController.abort(),this.abortController=new AbortController;const t=[...this.pendingResolvers];this.pendingResolvers=[],this.pendingPromise=this.makeRequest().then(e=>{const s=e.data.auth==="authenticated"&&e.data.user?{auth:"authenticated",user:e.data.user}:{auth:"unauthenticated",user:null};return t.forEach(({resolve:n})=>n(s)),s}).catch(e=>{if(e.name==="AbortError")return;const s={auth:"unauthenticated",user:null};return t.forEach(({resolve:n})=>n(s)),s}).finally(()=>{this.pendingPromise=null,this.abortController=null,this.coalesceTimer&&(clearTimeout(this.coalesceTimer),this.coalesceTimer=null)}),await this.pendingPromise}async makeRequest(){var i;const e=await fetch("/api/auth/me",{method:"GET",headers:{"Content-Type":"application/json",Accept:"application/json"},credentials:"same-origin",signal:(i=this.abortController)==null?void 0:i.signal}),s=e.headers.get("content-type");if(!(s&&s.includes("application/json")))throw new Error(`Server returned non-JSON response: ${e.status}`);const r=await e.json();if(e.status===200&&r.ok&&r.user)return{data:{auth:"authenticated",user:r.user}};if(e.status===401&&r.code==="AUTH_REQUIRED")return{data:{auth:"unauthenticated",user:null}};throw new Error(r.error||`HTTP ${e.status}`)}abort(){this.abortController&&this.abortController.abort(),this.coalesceTimer&&(clearTimeout(this.coalesceTimer),this.coalesceTimer=null)}}const l=new o;export{l as authMeClient};
